// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package dbqueries

import (
	"context"

	"github.com/google/uuid"
)

const addUserToChat = `-- name: AddUserToChat :exec
INSERT INTO chat_members (
    chat_id, user_id
) VALUES (
    $1, $2
)
ON CONFLICT DO NOTHING
`

type AddUserToChatParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) AddUserToChat(ctx context.Context, arg AddUserToChatParams) error {
	_, err := q.db.Exec(ctx, addUserToChat, arg.ChatID, arg.UserID)
	return err
}

const chatExists = `-- name: ChatExists :one
SELECT EXISTS (
    SELECT 1 FROM chats WHERE id = $1
)
`

func (q *Queries) ChatExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, chatExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (
    is_group
) VALUES (
    $1
)
RETURNING id, name, is_group, created_at
`

func (q *Queries) CreateChat(ctx context.Context, isGroup *bool) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat, isGroup)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedAt,
	)
	return i, err
}

const createGroupChat = `-- name: CreateGroupChat :one
INSERT INTO chats (
    name, is_group
) VALUES (
    $1, TRUE
)
RETURNING id, name, is_group, created_at
`

func (q *Queries) CreateGroupChat(ctx context.Context, name *string) (Chat, error) {
	row := q.db.QueryRow(ctx, createGroupChat, name)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    chat_id, sender_id, content
) VALUES (
    $1, $2, $3
)
RETURNING id, chat_id, sender_id, content, is_edited, created_at, updated_at
`

type CreateMessageParams struct {
	ChatID   uuid.UUID `json:"chat_id"`
	SenderID uuid.UUID `json:"sender_id"`
	Content  string    `json:"content"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.ChatID, arg.SenderID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
DELETE FROM chats
WHERE id = $1
`

func (q *Queries) DeleteChat(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChat, id)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const deleteMessages = `-- name: DeleteMessages :exec
DELETE FROM messages
WHERE chat_id = $1
`

func (q *Queries) DeleteMessages(ctx context.Context, chatID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessages, chatID)
	return err
}

const editMessage = `-- name: EditMessage :exec
UPDATE messages
SET
    content = $2,
    is_edited = TRUE,
    updated_at = NOW()
WHERE id = $1
RETURNING id, chat_id, sender_id, content, is_edited, created_at, updated_at
`

type EditMessageParams struct {
	ID      uuid.UUID `json:"id"`
	Content string    `json:"content"`
}

func (q *Queries) EditMessage(ctx context.Context, arg EditMessageParams) error {
	_, err := q.db.Exec(ctx, editMessage, arg.ID, arg.Content)
	return err
}

const getChatMembers = `-- name: GetChatMembers :many
SELECT user_id FROM chat_members
WHERE chat_id = $1
`

func (q *Queries) GetChatMembers(ctx context.Context, chatID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getChatMembers, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessages = `-- name: GetMessages :many
SELECT id, chat_id, sender_id, content, is_edited, created_at, updated_at FROM messages
WHERE chat_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetMessages(ctx context.Context, chatID uuid.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsEdited,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChats = `-- name: GetUserChats :many
SELECT c.id, c.name, c.is_group, c.created_at
FROM chats c
JOIN chat_members cm ON c.id = cm.chat_id
WHERE cm.user_id = $1
`

func (q *Queries) GetUserChats(ctx context.Context, userID uuid.UUID) ([]Chat, error) {
	rows, err := q.db.Query(ctx, getUserChats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chat{}
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsGroup,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserInChat = `-- name: IsUserInChat :one
SELECT EXISTS (
    SELECT 1 FROM chat_members WHERE chat_id = $1 AND user_id = $2
)
`

type IsUserInChatParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) IsUserInChat(ctx context.Context, arg IsUserInChatParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInChat, arg.ChatID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const messageExists = `-- name: MessageExists :one
SELECT EXISTS (
    SELECT 1 FROM messages WHERE id = $1
)
`

func (q *Queries) MessageExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, messageExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeUserFromChat = `-- name: RemoveUserFromChat :exec
DELETE FROM chat_members
WHERE chat_id = $1 AND user_id = $2
`

type RemoveUserFromChatParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveUserFromChat(ctx context.Context, arg RemoveUserFromChatParams) error {
	_, err := q.db.Exec(ctx, removeUserFromChat, arg.ChatID, arg.UserID)
	return err
}
